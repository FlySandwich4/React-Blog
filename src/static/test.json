[
  {
    "type": "TTitle",
    "postDate": "2024-05-22",
    "description": "A tutorial about goroutine in Golang",
    "title": "Clear Goroutine Instructions"
  },
  {
    "type": "TMarkdown",
    "title": "markdown",
    "content" : "# Go routine & concurrency\r\n\r\n# About this note\r\n\r\nThis note mainly discusses how we can use goroutines in basic ways, without focusing on what a goroutine is or the logic behind the mechanism.\r\n\r\n# What is a Goroutine\r\n\r\nA goroutine is like a thread, but not exactly. More specifically, it is much lighter than a thread. Compared to threads, goroutines require less performance and cost, which makes them really efficient. A scheduler is used to manage the goroutines, switching between them during runtime.\r\n\r\n# Why Goroutine\r\n\r\nIn traditional methods of coding for concurrency, we need to use mutex keys to keep the memory safe. We care about the shared memory and about whether \"we locked a mutex signal,\" \"Is the mutex signal now OK in a specific line of code?\" If you have ever tried to code concurrency in C, you probably know what I mean. If not, just imagine you need to think about a variable being shared by 10 files, with every file interacting with that variable at some lines of code. You have to carefully consider the current state of the variable and its future state.\r\n\r\nGoroutines solve this problem by using channels. The main idea is that \"channels care about data transformation.\" In other words, we don\u2019t modify or check data directly; we send or receive notifications that data has changed. You can learn more by reading the following notes.\r\n\r\n# Create Goroutine Codes\r\n\r\nTo create a goroutine\r\n\r\n```go \r\nfunc main() {\r\n\t\/\/ use go keyword to create a goroutine\r\n\tgo func() {\r\n\t\t... \/\/ the code will be execute in another go routine\r\n\t}() \/\/ call the func immediately\t\r\n}\r\n```\r\n\r\nTo create a channel, push data into a channel, get data from a channel. A channel is like a queue, follows the FIFO rule.\r\n\r\n```go\r\nfunc main() {\r\n\tc := make(chan struct) \/\/ make(chan [type])\r\n\tworker(c)\r\n\ttime.sleep(5 * time.second)\r\n\tc <- struct{}{} \/\/ push a empty struct instance to channel\r\n\ttime.sleep(5 * time.second) \/\/ wait for the worker finish printing\r\n\treturn\r\n}\r\n\r\nfunc worker(c chan struct{}) { \/\/ the parameter type is \"chan struct\"\r\n\tfmt.println(\"worker waiting for data\")\r\n\t\/\/ get data from c, <- means pop the first data from c, \r\n\t\/\/ we could get the value like this: var1 := <-c, but now we ignore the return\r\n\t\/\/ value since it is only a empty struct, we don't care, so we write <-c only\r\n\t<-c \r\n\tfmt.println(\"worker finished\")\r\n}\r\n```\r\n\r\n# Exit Goroutine in Several ways\r\n\r\n## Detached mode\r\n\r\nDetached mode means \u201CThe goroutine who create the current goroutine, doesn\u2019t care about the current goroutine\u201D As the current goroutine finish all the codes inside the function, the current goroutine die. There are 2 common usages:\r\n\r\n1. One-time task: In this example, we want the goroutine do something once, and we don\u2019t care how it exit or what value it will return.\r\n\r\n```go\r\nfunc OneTimeTask() {\r\n\tfmt.Println(\"main goroutine started\")\r\n\tc := make(chan int)\r\n\tgo func(c chan int) {\r\n\t\tfmt.Println(\"new goroutine started\")\r\n\t\tselect {\r\n\t\tcase val := <-c:\r\n\t\t\t\/\/ do something...\r\n\t\t\tfmt.Println(val)\r\n\t\tcase <-time.After(2 * time.Second):\r\n\t\t\t\/\/ timeout, do something...\r\n\t\t}\r\n\t\t\/\/ no codes here, so the goroutine exit\r\n\t}(c)\r\n\tfmt.Println(\"main goroutine created another goroutine\")\r\n\ttime.Sleep(time.Second)     \/\/ sleep 1 sec\r\n\tc <- 1                      \/\/ push 1 to channel\r\n\ttime.Sleep(5 * time.Second) \/\/ sleep to make sure the goroutine we created exit\r\n\tfmt.Println(\"main goroutine ends\")\r\n}\r\n\r\n\/\/ main goroutine started\r\n\/\/ main goroutine created another goroutine\r\n\/\/ new goroutine started\r\n\/\/ 1\r\n\/\/ main goroutine ends\r\n```\r\n\r\n2. Background tasks: Like monitor or timer that trigger some kind of methods based on some kind of situations over and over again.\r\n\r\n```go\r\nfunc AddMonitorToTasks() {\r\n\t\/\/ suppose we have some tasks\r\n\ttasks := []int{1,2,3,4,5}\r\n\tfor i := range tasks {\r\n\t\tgo func(i int) {\r\n\t\t\ttime.Sleep(2 * time.Second)\r\n\t\t\tfmt.Println(\"monitoring:\", i)\r\n\t\t\t\/\/ you can add a for loop here to monitor the task after a period of time\r\n\t\t}(i) \r\n\t\t\/\/ do not use closure here, because all go routinue will share the same varibale if we use closure\r\n\t\t\/\/ now, we are passing the variable inside the function, which is a copy of the variable\r\n\t}\r\n\ttime.Sleep(5 * time.Second)\r\n}\r\n\r\n\/\/ note: your result might be different from the result below\r\n\/\/ monitoring: 2\r\n\/\/ monitoring: 1\r\n\/\/ monitoring: 0\r\n\/\/ monitoring: 4\r\n\/\/ monitoring: 3\r\n```\r\n\r\n## Join Mode\r\n\r\nIf the parent goroutine needs information from its children goroutines, we can call it \u201Cjoin mode\u201D which means parent should wait for its children, or the parent cares about the children\u2019s results. There are several ways of \u201Cjoining\u201D:\r\n\r\n> Join Mode isn\u2019t a well known name. This term comes from a book which listed in the reference part.\r\n> \r\n1. Wait a single goroutine\r\n\r\n```go\r\nfunc WaitSingle() {\r\n\tc := make(chan struct{})\r\n\tgo func() {\r\n\t\t\/\/ do some work here\r\n\t\ttime.Sleep(2 * time.Second)\r\n\t\t\/\/ work done\r\n\t\tc <- struct{}{} \/\/ push a signal to the channel\r\n\t}()\r\n\tfmt.Println(\"parent started waiting\")\r\n\t<-c \/\/ the program will stop here until recieving the signal\r\n\tfmt.Println(\"parent got result\")\r\n}\r\n\r\n\/\/ parent started waiting\r\n\/\/ parent got result\r\n```\r\n\r\n2. Get the status from the exited goroutine\r\n\r\n```go\r\nfunc GetStatus() {\r\n\tc := make(chan error) \/\/ we make a error channel here\r\n\tgo func() {\r\n\t\t\/\/ do some work here\r\n\t\ttime.Sleep(2 * time.Second)\r\n\t\terr := errors.New(\"there is an error\") \/\/ simulate error\r\n\t\tif err != nil {\r\n\t\t\tc <- err\r\n\t\t\treturn\r\n\t\t}\r\n\t\t\/\/ work done\r\n\t\tc <- nil \/\/ push a signal to the channel\r\n\t}()\r\n\tfmt.Println(\"parent started waiting\")\r\n\terr := <-c \/\/ the program will stop here until recieving the signal\r\n\tfmt.Println(\"parent got result\")\r\n\tfmt.Println(\"err is:\", err.Error())\r\n}\r\n\r\n\/\/ parent started waiting\r\n\/\/ parent got result\r\n\/\/ err is: there is an error\r\n```\r\n\r\n3. Wait multiple goroutines\r\n\r\n```go\r\nfunc WaitMutiple() {\r\n\tc := make(chan struct{})\r\n\tvar wg sync.WaitGroup\r\n\tfmt.Println(\"assigning tasks\")\r\n\tfor i := 0; i < 10; i++ {\r\n\t\twg.Add(1) \/\/ add a task to the wait group\r\n\t\tgo func(i int) {\r\n\t\t\ttime.Sleep(3 * time.Second)\r\n\t\t\tfmt.Println(\"task\", i, \"done\")\r\n\t\t\twg.Done()\r\n\t\t}(i)\r\n\t}\r\n\t\/\/ we use another goroutine to wait for all tasks to be done\r\n\t\/\/ wait until all tasks are done, then send a signal to the channel\r\n\tgo func() {\r\n\t\twg.Wait() \r\n\t\tc <- struct{}{}\r\n\t}()\r\n\t<-c\r\n\tfmt.Println(\"tasks end\")\r\n}\r\n\r\n\/\/ assigning tasks\r\n\/\/ task 2 done\r\n\/\/ task 7 done\r\n\/\/ task 5 done\r\n\/\/ task 1 done\r\n\/\/ task 0 done\r\n\/\/ task 3 done\r\n\/\/ task 4 done\r\n\/\/ task 8 done\r\n\/\/ task 6 done\r\n\/\/ task 9 done\r\n\/\/ tasks end\r\n```\r\n\r\n## Notify-and-wait Mode\r\n\r\nIn the previous part, we discussed about how the main goroutine wait for children goroutines end. Now, we are going to discuss how we can notify a child goroutine end.\r\n\r\n1. Notify a goroutine\r\n\r\n```go\r\nfunc NotifyOne() {\r\n\tquit := make(chan string)\r\n\tgo func() {\r\n\t\tfor {\r\n\t\t\tselect {\r\n\t\t\tcase <-time.After(time.Second):\r\n\t\t\t\tfmt.Println(\"work after 1 sec\")\r\n\t\t\tcase <-quit:\r\n\t\t\t\tquit <- \"ok\"\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t}()\r\n\ttime.Sleep(5 * time.Second)\r\n\tquit <- \"end\" \/\/ sending a signal to the channel, doesn't has to be \"end\"\r\n\tstatus := <-quit \/\/ a bi-directional channel, the internal goroutine send a signal back\r\n\tfmt.Println(status)\r\n}\r\n\r\n\/\/ work after 1 sec\r\n\/\/ work after 1 sec\r\n\/\/ work after 1 sec\r\n\/\/ work after 1 sec\r\n\/\/ ok\r\n```\r\n\r\n2. Notify multiple goroutines\r\n\r\nHere, a point is that when we closing a channel, it will send a signal to all the goroutines that waiting for the channel. You can check the variable `ok` in the `go func` , which will be false if the channel is closed. We can use this characteristic to notify multiple goroutines.\r\n\r\n```go\r\nfunc NotifyMutiple() {\r\n\tjob := make(chan int)\r\n\tvar wg sync.WaitGroup\r\n\t\/\/ create 10 goroutines\r\n\tfor i := 0; i < 10; i++ {\r\n\t\twg.Add(1) \r\n\t\tgo func(i int) {\r\n\t\t\tfor {\r\n\t\t\t\tnum, ok := <-job\r\n\t\t\t\tif !ok {\r\n\t\t\t\t\twg.Done()\r\n\t\t\t\t\tfmt.Println(\"Goroutine\", i, \"done\")\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\tfmt.Println(\"Gorouinte\", i, \"is working on job\", num)\r\n\t\t\t}\r\n\t\t}(i)\r\n\t}\r\n\t\/\/ adding tasks to job channel\r\n\tfor i := 0; i < 10; i++ {\r\n\t\tjob <- i\r\n\t}\r\n\t\r\n\ttime.Sleep(5 * time.Second) \/\/ wait for jobs to be done\r\n\tclose(job) \/\/ closing a channel will notify all the goroutines that waiting for the channel\r\n\twg.Wait()\r\n\tfmt.Println(\"job done\")\r\n}\r\n\r\n\/\/ Gorouinte 8 is working on job 9\r\n\/\/ Gorouinte 0 is working on job 0\r\n\/\/ Gorouinte 5 is working on job 3\r\n\/\/ Gorouinte 1 is working on job 1\r\n\/\/ Gorouinte 7 is working on job 6\r\n\/\/ Gorouinte 4 is working on job 2\r\n\/\/ Gorouinte 2 is working on job 5\r\n\/\/ Gorouinte 3 is working on job 7\r\n\/\/ Gorouinte 6 is working on job 4\r\n\/\/ Gorouinte 9 is working on job 8\r\n\/\/ Goroutine 8 done\r\n\/\/ Goroutine 4 done\r\n\/\/ Goroutine 9 done\r\n\/\/ Goroutine 2 done\r\n\/\/ Goroutine 6 done\r\n\/\/ Goroutine 1 done\r\n\/\/ Goroutine 7 done\r\n\/\/ Goroutine 5 done\r\n\/\/ Goroutine 3 done\r\n\/\/ Goroutine 0 done\r\n\/\/ job done\r\n```\r\n\r\n# Pipeline\r\n\r\nWe can have multiple different tasks running at the same time, which is shown in the codes below. Every function is handled by a goroutine. After a function is finished, it will send the result to the next goroutine. Finally, the last function send the result to the end channel.\r\n\r\n```go\r\nfunc Pipeline() {\r\n\tquit := make(chan struct{})\r\n\tadd1 := func(i int) int {\r\n\t\treturn i + 1\r\n\t}\r\n\ttimes2 := func(i int) int {\r\n\t\treturn i * 2\r\n\t}\r\n\tsquare := func(i int) int {\r\n\t\treturn i * i\r\n\t}\r\n\tdoTask := func(c <-chan int, f func(int) int) <-chan int {\r\n\t\tout := make(chan int)\r\n\t\tgo func() {\r\n\t\t\tdefer close(out) \/\/ Ensure the channel is closed when the goroutine exits\r\n\t\t\tfor {\r\n\t\t\t\tselect {\r\n\t\t\t\tcase num, ok := <-c:\r\n\t\t\t\t\tif !ok {\r\n\t\t\t\t\t\treturn \/\/ Exit the goroutine if the input channel is closed\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfmt.Println(\"calling function\", f)\r\n\t\t\t\t\tresultNum := f(num)\r\n\t\t\t\t\tout <- resultNum\r\n\t\t\t\tcase <-quit:\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}()\r\n\t\treturn out\r\n\t}\r\n\r\n\tc := make(chan int) \/\/ initial channel where we put data in\r\n\tresultChannel := doTask(doTask(doTask(c, add1), times2), square) \/\/ calling 3 functions in a pipeline\r\n\tgo func() {\r\n\t\tfor {\r\n\t\t\tselect {\r\n\t\t\tcase result, ok := <-resultChannel:\r\n\t\t\t\tif !ok {\r\n\t\t\t\t\treturn \/\/ Exit the goroutine if the result channel is closed\r\n\t\t\t\t}\r\n\t\t\t\tfmt.Println(\"result:\", result)\r\n\t\t\tcase <-quit:\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\t}()\r\n\t\/\/ simulate some tasks\r\n\tc <- 1\r\n\tc <- 2\r\n\tc <- 0\r\n\tclose(c) \/\/ Close the input channel after sending all values\r\n\ttime.Sleep(5 * time.Second)\r\n\tclose(quit)\r\n}\r\n\r\n\/\/ calling function 0xc75b40\r\n\/\/ calling function 0xc75b40\r\n\/\/ calling function 0xc75b60\r\n\/\/ calling function 0xc75b60\r\n\/\/ calling function 0xc75b80\r\n\/\/ calling function 0xc75b80\r\n\/\/ calling function 0xc75b40\r\n\/\/ calling function 0xc75b60\r\n\/\/ result: 16\r\n\/\/ result: 36\r\n\/\/ calling function 0xc75b80\r\n\/\/ result: 4\r\n```\r\n\r\n# Conclusion\r\n\r\nHope you know some ways of writing goroutines after reading! In this note, we discussed how to create goroutines, exit goroutines in different ways, and utilize channel and go routines to make a pipeline. However, we didn\u2019t discuss a lot about channel. In the future, I will share more about some strategies of using channels."
  }

]